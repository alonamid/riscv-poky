--- ray-ray-0.2.1/src/common/redis_module/ray_redis_module.cc	2017-10-01 19:33:13.000000000 +0000
+++ ray-ray-0.2.1-new/src/common/redis_module/ray_redis_module.cc	2017-11-27 01:32:22.086953031 +0000
@@ -1,5 +1,9 @@
 #include "redismodule.h"
 #include <string.h>
+#include <time.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include "redis_string.h"
 
@@ -48,6 +52,13 @@
     return RedisModule_ReplyWithError(ctx, (MESSAGE)); \
   }
 
+#include "signal.h"
+#define FIRESIM_BUF_SIZE 100000
+uint64_t* firesim_profile_buffer1;
+uint64_t* firesim_profile_buffer2;
+uint64_t* firesim_profile_buffer_start1;
+uint64_t* firesim_profile_buffer_start2;
+
 RedisModuleKey *OpenPrefixedKey(RedisModuleCtx *ctx,
                                 const char *prefix,
                                 RedisModuleString *keyname,
@@ -454,6 +465,13 @@
 int ObjectTableAdd_RedisCommand(RedisModuleCtx *ctx,
                                 RedisModuleString **argv,
                                 int argc) {
+
+  uint64_t firesim_rdcycle;
+  asm volatile ("rdcycle %0 \n\t" :"=r"(firesim_rdcycle):);
+  *firesim_profile_buffer2 = firesim_rdcycle;
+  firesim_profile_buffer2 = firesim_profile_buffer2 + 1;
+
+
   if (argc != 5) {
     return RedisModule_WrongArity(ctx);
   }
@@ -1014,6 +1032,13 @@
 int TaskTableAddTask_RedisCommand(RedisModuleCtx *ctx,
                                   RedisModuleString **argv,
                                   int argc) {
+
+  uint64_t firesim_rdcycle;
+  asm volatile ("rdcycle %0 \n\t" :"=r"(firesim_rdcycle):);
+  *firesim_profile_buffer1 = firesim_rdcycle;
+  firesim_profile_buffer1 = firesim_profile_buffer1 + 1;
+
+
   if (argc != 5) {
     return RedisModule_WrongArity(ctx);
   }
@@ -1143,8 +1168,75 @@
   return ReplyWithTask(ctx, argv[1], false);
 }
 
+
 extern "C" {
 
+void signal_handler(int signal) {
+
+  //==========================================================
+  //===================Alon's Profiling Code===================
+  //==========================================================
+  time_t rawtime;
+  char buffer [255];
+
+  srand( (unsigned) time(NULL) * getpid() );
+  int r = rand();
+
+  rawtime = time (NULL);
+  sprintf(buffer,"/home/ray_redis_module_TaskTableAddTask.prof.%d.%d",(uintmax_t)rawtime,r );
+
+  FILE* prof_f1 = fopen(buffer, "w+");
+  if (prof_f1 == NULL)
+  {
+      printf("Error opening prof_f1 file!\n");
+      exit(1);
+  }
+  
+  for (int i=0; i<FIRESIM_BUF_SIZE; i++)
+  {
+      fprintf(prof_f1, "%016llx\n",firesim_profile_buffer_start1[i]);
+  }
+  fclose(prof_f1);
+  free(firesim_profile_buffer_start1);
+
+  sprintf(buffer,"/home/ray_redis_module_ObjectTableAdd.prof.%d.%d",(uintmax_t)rawtime,r );
+  FILE* prof_f2 = fopen(buffer, "w+");
+  if (prof_f2 == NULL)
+  {
+      printf("Error opening prof_f2 file!\n");
+      exit(1);
+  }
+  
+  for (int i=0; i<FIRESIM_BUF_SIZE; i++)
+  {
+      fprintf(prof_f2, "%016llx\n",firesim_profile_buffer_start2[i]);
+  }
+  fclose(prof_f2);
+  free(firesim_profile_buffer_start2);
+
+  //==========================================================
+  //=============================================
+
+  if (signal == SIGTERM) {
+    exit(0);
+  }
+
+  if (signal == SIGKILL) {
+    exit(0);
+  }
+
+  if (signal == SIGINT) {
+    exit(0);
+  }
+
+
+}
+
+
+
+
+
+
 /* This function must be present on each Redis module. It is used in order to
  * register the commands into the Redis server. */
 int RedisModule_OnLoad(RedisModuleCtx *ctx,
@@ -1153,6 +1245,15 @@
   REDISMODULE_NOT_USED(argv);
   REDISMODULE_NOT_USED(argc);
 
+  firesim_profile_buffer_start1 = (uint64_t*)aligned_alloc(64,5000000*sizeof(uint64_t));
+  firesim_profile_buffer1 = firesim_profile_buffer_start1;
+  firesim_profile_buffer_start2 = (uint64_t*)aligned_alloc(64,5000000*sizeof(uint64_t));
+  firesim_profile_buffer2 = firesim_profile_buffer_start2;
+  signal(SIGTERM, signal_handler);
+  signal(SIGINT, signal_handler);
+  signal(SIGKILL, signal_handler);
+
+
   if (RedisModule_Init(ctx, "ray", 1, REDISMODULE_APIVER_1) ==
       REDISMODULE_ERR) {
     return REDISMODULE_ERR;
